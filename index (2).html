<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent Visual C++ Matrix Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: #333; direction: ltr; }
        .header { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); padding: 1rem 2rem; box-shadow: 0 2px 20px rgba(0,0,0,0.1); display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.2); gap: 1rem; }
        .main-container { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; padding: 2rem; max-width: 1400px; margin: 0 auto; }
        .result-section { grid-column: 1 / -1; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-radius: 16px; padding: 2rem; box-shadow: 0 8px 32px rgba(0,0,0,0.1); margin-top: 1rem; }
        .logo { font-size: 1.5rem; font-weight: bold; color: #667eea; }
        .image-section, .code-section { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); border-radius: 16px; padding: 2rem; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        .section-title { font-size: 1.3rem; font-weight: bold; margin-bottom: 1.5rem; color: #667eea; }
        .upload-area { border: 3px dashed #667eea; border-radius: 12px; padding: 2rem; text-align: center; cursor: pointer; transition: all 0.3s ease; margin-bottom: 2rem; }
        .upload-area:hover { border-color: #764ba2; background: rgba(102, 126, 234, 0.05); }
        .image-grid { display: grid; gap: 2px; margin-top: 2rem; justify-content: center; background: #ddd; padding: 2px; border-radius: 8px; }
        .image-grid.grid-3x3 { grid-template-columns: repeat(3, 100px); grid-template-rows: repeat(3, 100px); }
        .image-chunk { background-size: cover; background-position: center; border-radius: 4px; position: relative; transition: all 0.4s ease-in-out; }
        .chunk-label { position: absolute; top: 2px; left: 2px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: bold; }
        .code-editor { width: 100%; height: 300px; font-family: 'Courier New', monospace; font-size: 14px; padding: 1rem; border: 2px solid #ddd; border-radius: 8px; resize: vertical; background: #f8f9fa; line-height: 1.5; }
        .button-container { display: flex; gap: 1rem; margin-top: 1rem; }
        .execute-btn, .reset-btn { flex-grow: 1; border: none; padding: 1rem 1.5rem; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: bold; transition: transform 0.2s ease; margin-top:0; }
        .execute-btn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .reset-btn { background: #6c757d; color: white; }
        .execute-btn:disabled, .reset-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .matrix-display { display: flex; gap: 2rem; align-items: flex-start; flex-wrap: wrap; }
        .matrix-box { background: #f8f9fa; border-radius: 8px; padding: 1rem; border: 2px solid #ddd; }
        .matrix-title { font-weight: bold; margin-bottom: 0.5rem; color: #667eea; }
        .matrix-grid { display: grid; gap: 4px; }
        .matrix-grid.grid-3x3 { grid-template-columns: repeat(3, 40px); }
        .error-message { background: #fee; border: 1px solid #fcc; color: #c00; padding: 1rem; border-radius: 8px; margin-top: 1rem; white-space: pre-wrap; text-align: left; font-family: 'Courier New', monospace; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite; margin-left: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @media (max-width: 992px) { .main-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">Intelligent Visual C++ Matrix Simulator</div>
    </div>

    <div class="main-container">
        <div class="image-section">
            <h2 class="section-title">Image Grid (3x3)</h2>
            <div class="upload-area" id="uploadArea">
                <p>Drag & Drop an image here or click to upload</p>
                <input type="file" id="imageInput" accept="image/*" style="display: none;">
            </div>
            <div id="imageGrid" class="image-grid grid-3x3"></div>
        </div>

        <div class="code-section">
            <h2 class="section-title">C++ Code Editor</h2>
            <textarea id="codeEditor" class="code-editor" placeholder="Write your C++ code here..."></textarea>
            <div class="button-container">
                <button id="executeBtn" class="execute-btn">‚ñ∂Ô∏è Execute Code</button>
                <button id="resetBtn" class="reset-btn">üîÑ Reset</button>
            </div>
        </div>
    </div>

    <div class="result-section">
        <h2 class="section-title">Output</h2>
        <div class="matrix-display" id="matrixDisplay"></div>
        <div id="errorMessage"></div>
    </div>

    <script>
        let originalMatrix = [];
        let imageChunks = [];

        const uploadArea = document.getElementById('uploadArea');
        const imageInput = document.getElementById('imageInput');
        const imageGrid = document.getElementById('imageGrid');
        const codeEditor = document.getElementById('codeEditor');
        const executeBtn = document.getElementById('executeBtn');
        const resetBtn = document.getElementById('resetBtn');
        const matrixDisplay = document.getElementById('matrixDisplay');
        const errorMessage = document.getElementById('errorMessage');

        uploadArea.addEventListener('click', () => imageInput.click());
        uploadArea.addEventListener('dragover', (e) => e.preventDefault());
        uploadArea.addEventListener('drop', (e) => { e.preventDefault(); if (e.dataTransfer.files.length) processImage(e.dataTransfer.files[0]); });
        imageInput.addEventListener('change', (e) => { if (e.target.files.length) processImage(e.target.files[0]); });
        executeBtn.addEventListener('click', () => executeCode(codeEditor.value));
        resetBtn.addEventListener('click', resetState);

        function processImage(file) {
            const reader = new FileReader();
            reader.onload = e => { const img = new Image(); img.onload = () => sliceImage(img); img.src = e.target.result; };
            reader.readAsDataURL(file);
        }

        function sliceImage(img) {
            const size = 3;
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, 300, 300);
            imageChunks = [];
            originalMatrix = [];
            const chunkSize = 300 / size;
            let index = 0;
            for (let i = 0; i < size; i++) {
                originalMatrix[i] = [];
                for (let j = 0; j < size; j++) {
                    const chunkCanvas = document.createElement('canvas');
                    chunkCanvas.width = chunkSize;
                    chunkCanvas.height = chunkSize;
                    const chunkCtx = chunkCanvas.getContext('2d');
                    chunkCtx.drawImage(canvas, j * chunkSize, i * chunkSize, chunkSize, chunkSize, 0, 0, chunkSize, chunkSize);
                    imageChunks.push(chunkCanvas.toDataURL());
                    originalMatrix[i][j] = index++;
                }
            }
            updateImageDisplay(originalMatrix);
            matrixDisplay.innerHTML = '';
            displayMatrix('Initial Matrix', originalMatrix);
        }

        // [UPGRADED] Smart analysis engine to detect visual transformations
        function analyzeCodeForTransformation(code) {
            const sanitizedCode = code.replace(/\s/g, '');
            if (/\w+\[j\]\[size-1-i\]=\w+\[i\]\[j\]/.test(sanitizedCode)) return { rotate: 90, scale: '' };
            if (/\w+\[size-1-j\]\[i\]=\w+\[i\]\[j\]/.test(sanitizedCode)) return { rotate: -90, scale: '' };
            if (/\w+\[size-1-i\]\[size-1-j\]=\w+\[i\]\[j\]/.test(sanitizedCode)) return { rotate: 180, scale: '' };
            const vFlip = /\w+\[size-1-i\]\[j\]=\w+\[i\]\[j\]|swap\((?:std::)?\w+\[i\]\[j\],\w+\[size-1-i\]\[j\]\)|swap\((?:std::)?\w+\[size-1-i\]\[j\],\w+\[i\]\[j\]\)/;
            if (vFlip.test(sanitizedCode)) return { rotate: 0, scale: 'scaleY(-1)' };
            const hFlip = /\w+\[i\]\[size-1-j\]=\w+\[i\]\[j\]|swap\((?:std::)?\w+\[i\]\[j\],\w+\[i\]\[size-1-j\]\)|swap\((?:std::)?\w+\[i\]\[size-1-j\],\w+\[i\]\[j\]\)/;
            if (hFlip.test(sanitizedCode)) return { rotate: 0, scale: 'scaleX(-1)' };
            const transpose = /\w+\[j\]\[i\]=\w+\[i\]\[j\]|swap\((?:std::)?\w+\[i\]\[j\],\w+\[j\]\[i\]\)|swap\((?:std::)?\w+\[j\]\[i\],\w+\[i\]\[j\]\)/;
            if (transpose.test(sanitizedCode)) return { rotate: 90, scale: 'scaleX(-1)' };
            return { rotate: 0, scale: '' };
        }

        function buildFullCode(userCode, matrix) {
            const size = matrix.length;
            const matrixNameRegex = /int\s+([a-zA-Z_]\w*)\s*\[\s*(?:\d+|size)\s*\]\s*\[\s*(?:\d+|size)\s*\]\s*;?/;
            const match = userCode.match(matrixNameRegex);
            let matrixNameToPrint = 'arr', processedUserCode = userCode, sizeDeclaration = `const int size = ${size};`;
            if (/const\s+int\s+size/.test(userCode)) sizeDeclaration = '';
            const matrixInitString = ` = {${matrix.map(row => `{${row.join(',')}}`).join(',')}}`;
            if (match) {
                matrixNameToPrint = match[1];
                processedUserCode = userCode.replace(match[0], `${match[0].replace(';', '')}${matrixInitString};`);
            } else {
                processedUserCode = `int arr[${size}][${size}]${matrixInitString};\n${userCode}`;
            }
            return `#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    ${sizeDeclaration}\n${processedUserCode}\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size; ++j) {\n            std::cout << ${matrixNameToPrint}[i][j] << (j == size - 1 ? "" : " ");\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}`;
        }
        
        async function executeCode(userCode) {
            if (originalMatrix.length === 0) { showError('Please upload an image first.'); return; }
            if (!userCode.trim()) { showError('Code editor is empty.'); return; }

            executeBtn.disabled = true;
            resetBtn.disabled = true;
            executeBtn.innerHTML = '‚è≥ Executing... <div class="loading"></div>';
            clearError();
            
            const oldResult = document.querySelector('.matrix-box[data-title="Result Matrix"]');
            if(oldResult) oldResult.remove();
            
            const visualTransform = analyzeCodeForTransformation(userCode);
            const fullCode = buildFullCode(userCode, originalMatrix);
            const apiPayload = { compiler: "gcc-head", code: fullCode, options: "c++2a,warning,gnu" };

            try {
                const response = await fetch('https://wandbox.org/api/compile.json', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(apiPayload) });
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                
                const result = await response.json();
                if (result.compiler_error || result.program_error) throw new Error(result.compiler_error || result.program_error);
                
                const resultMatrix = result.program_output.trim().split('\n').map(row => 
                    row.trim().split(/\s+/).map(cell => parseInt(cell, 10))
                );
                
                if (resultMatrix.length !== 3 || resultMatrix.some(row => isNaN(row[0]) || row.length !== 3)) {
                    throw new Error('Output is not a valid 3x3 matrix.');
                }
                
                updateImageDisplay(resultMatrix, visualTransform);
                displayMatrix('Result Matrix', resultMatrix);

            } catch (error) {
                showError(`Execution Error:\n${error.message}`);
            } finally {
                executeBtn.disabled = false;
                resetBtn.disabled = false;
                executeBtn.innerHTML = '‚ñ∂Ô∏è Execute Code';
            }
        }
        
        function resetState() {
            if (originalMatrix.length > 0) updateImageDisplay(originalMatrix);
            const resultBox = document.querySelector('.matrix-box[data-title="Result Matrix"]');
            if (resultBox) resultBox.remove();
            codeEditor.value = '';
            clearError();
        }

        function updateImageDisplay(matrix, transform = { rotate: 0, scale: '' }) {
            imageGrid.innerHTML = '';
            const flatMatrix = matrix.flat();
            flatMatrix.forEach(imageValue => {
                if (imageChunks[imageValue] === undefined) return;
                const chunkDiv = document.createElement('div');
                chunkDiv.className = 'image-chunk';
                chunkDiv.style.backgroundImage = `url(${imageChunks[imageValue]})`;
                chunkDiv.style.transform = `${transform.scale} rotate(${transform.rotate}deg)`;
                chunkDiv.innerHTML = `<div class="chunk-label">${imageValue}</div>`;
                imageGrid.appendChild(chunkDiv);
            });
        }

        function displayMatrix(title, matrix) {
            const existingMatrix = document.querySelector(`.matrix-box[data-title="${title}"]`);
            if(existingMatrix) existingMatrix.remove();
            const matrixBox = document.createElement('div');
            matrixBox.className = 'matrix-box';
            matrixBox.setAttribute('data-title', title);
            const titleDiv = document.createElement('div');
            titleDiv.className = 'matrix-title';
            titleDiv.textContent = title;
            const matrixGridDiv = document.createElement('div');
            matrixGridDiv.className = `matrix-grid grid-3x3`;
            matrix.forEach(row => row.forEach(cellValue => {
                const cell = document.createElement('div');
                cell.className = 'matrix-cell';
                cell.textContent = cellValue;
                matrixGridDiv.appendChild(cell);
            }));
            matrixBox.append(titleDiv, matrixGridDiv);
            matrixDisplay.appendChild(matrixBox);
        }

        function showError(message) { errorMessage.innerHTML = `<div class="error-message">‚ùå ${message}</div>`; }
        function clearError() { errorMessage.innerHTML = ''; }

        function createDefaultPattern() {
            const canvas = document.createElement('canvas');
            canvas.width = 300;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE'];
            let index = 0;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    ctx.fillStyle = colors[index % colors.length];
                    ctx.fillRect(j * 100, i * 100, 100, 100);
                    ctx.fillStyle = 'white';
                    ctx.font = `bold 24px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(index, j * 100 + 50, i * 100 + 50);
                    index++;
                }
            }
            canvas.toBlob(blob => processImage(new File([blob], 'pattern.png', { type: 'image/png' })));
        }

        window.onload = () => createDefaultPattern();
    </script>
</body>
</html>